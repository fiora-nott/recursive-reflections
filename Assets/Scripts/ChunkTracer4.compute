#pragma kernel CSMain

RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;

//Texture3D<int> Blocks;
StructuredBuffer<int> BlockBuffer;
StructuredBuffer<int> ChunkBuffer;
int ChunkDomain;
int ChunkSize;

int MaxReflects;
int ShadowsOn;
int OverwriteColor;
float4 OverwriteValue;

bool ChunkInBounds(int3 chunkPosition) {
    return (
        chunkPosition.x >= 0 &&
        chunkPosition.y >= 0 &&
        chunkPosition.z >= 0 &&
        chunkPosition.x < ChunkDomain &&
        chunkPosition.y < ChunkDomain &&
        chunkPosition.z < ChunkDomain);
}

int GetChunk(int3 chunkPos) {
    return ChunkBuffer[chunkPos.z + ChunkDomain * (chunkPos.y + chunkPos.x * ChunkDomain)];
}

float4 ParseChunkColor(int chunkValue) {
    int r = (chunkValue >> 18) & 0x3F;
    int g = (chunkValue >> 12) & 0x3F;
    int b = (chunkValue >> 6) & 0x3F;
    int a = (chunkValue >> 0) & 0x3F;
    float4 color = float4(r, g, b, a) / 64;
    return color;
}

bool BlockInBounds(int3 blockPos) {
    return (
        blockPos.x >= 0 &&
        blockPos.y >= 0 &&
        blockPos.z >= 0 &&
        blockPos.x < ChunkSize &&
        blockPos.y < ChunkSize &&
        blockPos.z < ChunkSize);
}

bool PositionInBounds(int3 worldPos) {
    return (
        worldPos.x >= 0 &&
        worldPos.y >= 0 &&
        worldPos.z >= 0 &&
        worldPos.x < ChunkSize * ChunkDomain &&
        worldPos.y < ChunkSize * ChunkDomain &&
        worldPos.z < ChunkSize * ChunkDomain);
}


float4 GetBlock(int3 blockPos, int3 chunkPos) {
    int indexBlock = (int)(blockPos.z + ChunkSize * (blockPos.y + blockPos.x * ChunkSize));
    int indexChunk = GetChunk(chunkPos);
    int indexReal = indexBlock + indexChunk;
    int blockValue = BlockBuffer[indexReal];
    int a = (blockValue >> 0) & 0xFF;
    int b = (blockValue >> 8) & 0xFF;
    int g = (blockValue >> 16) & 0xFF;
    int r = (blockValue >> 24) & 0xFF;
    return float4(r, g, b, a) / 255;
}


int3 DDA_OneUnit(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x + 1 - rayOrigin.x;
        else
            distance.x = blockPos.x - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y + 1 - rayOrigin.y;
        else
            distance.y = blockPos.y - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z + 1 - rayOrigin.z;
        else
            distance.z = blockPos.z - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x <= mag.y && mag.x <= mag.z) {
        return blockPos + int3(sign(rayDir.x), 0, 0);
    }
    else if (valid.y && mag.y <= mag.z) {
        return blockPos + int3(0, sign(rayDir.y), 0);
    }
    else {
        return blockPos + int3(0, 0, sign(rayDir.z));
    }
}

int3 Planar(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    // These points represent where all 3 planes intersect
    // There are 2^3=8 possible point-pairs for a given block,
    // Depending on the ray direction
    int3 maxBound = blockPos + int3(1, 1, 1);
    int3 minBound = blockPos;
    // If the ray is traversing across the x-axis
    if (rayDir.x != 0) {
        // See where the ray will next intersect a Z-Y plane (measuring x traversal)
        // Start by obtaining the delta-x value
        float delta;
        if (rayDir.x >= 0) {
            delta = maxBound.x - rayOrigin.x;
        }
        else {
            delta = minBound.x - rayOrigin.x;
        }
        // Find the position on the ray where it hits the plane
        // Since we have like triangles, we only need 1 scalar to find new hypotenuse
        float scaleFactor = delta / rayDir.x; //negative if given impossible blockpos
        float3 hit = rayOrigin + rayDir * scaleFactor;

        // Now we check if our planar intersection is along the block's bounds
        float3 uv;
        uv.x = 0;
        uv.y = hit.y;
        uv.z = hit.z;
        // See if the z and y values is within the defined domains of the block face
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.y >= minBound.y && uv.y <= maxBound.y) {
            // We succesfully found our escape position
            // Calculate the block pos here (outed) and return
            float3 indexOffset = float3(sign(rayDir.x), 0, 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }


    if (rayDir.y != 0) {
        float delta;
        if (rayDir.y >= 0)
            delta = maxBound.y - rayOrigin.y;
        else
            delta = minBound.y - rayOrigin.y;
        float scaleFactor = delta / rayDir.y;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = 0;
        uv.z = hit.z;
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, sign(rayDir.y), 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }
    if (rayDir.z != 0) {
        float delta;
        if (rayDir.z >= 0)
            delta = maxBound.z - rayOrigin.z;
        else
            delta = minBound.z - rayOrigin.z;
        float scaleFactor = delta / rayDir.z;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = hit.y;
        uv.z = 0;
        if (uv.y >= minBound.y && uv.y <= maxBound.y &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, 0, sign(rayDir.z)) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }

    return blockPos + int3(0, 1, 0);
}

float3 FindEntryPoint(float3 rayOrigin, float3 rayDir, int3 blockPos, out int3 normal) {
    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x - rayOrigin.x;
        else
            distance.x = blockPos.x + 1 - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y - rayOrigin.y;
        else
            distance.y = blockPos.y + 1 - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z - rayOrigin.z;
        else
            distance.z = blockPos.z + 1 - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x >= mag.y && mag.x >= mag.z) {
        normal = int3(-sign(rayDir.x), 0, 0);
        return rayOrigin + rayDir * mag.x;
    }
    else if (valid.y && mag.y >= mag.z) {
        normal = int3(0, -sign(rayDir.y), 0);
        return rayOrigin + rayDir * mag.y;
    }
    else {
        normal = int3(0, 0, -sign(rayDir.z));
        return rayOrigin + rayDir * mag.z;
    }
}

bool RayMarch(float3 rayOrigin, float3 rayDir, out float3 hitPoint, out float3 hitReflection, out float4 hitColor) {

    float3 rayPos = rayOrigin;

    //int3 globalBlockPos = floor(rayOrigin);
    //int3 chunkPos = (floor(globalBlockPos / ChunkSize));
    //int3 blockPos = globalBlockPos - chunkPos * ChunkSize;
    int3 blockPos = floor(rayOrigin);
    int3 chunkPos;
    int3 localPos;
    int steps = 0;
    float4 skyColor = float4(0.7, 0.8, 1.0, 1.0);
    skyColor.r = -rayDir.z;
    skyColor.g = abs(rayDir.x);
    skyColor.b = rayDir.z;
    skyColor.r = clamp(skyColor.r, 0.6, 1.0);
    skyColor.g = clamp(skyColor.g, 0.4, 0.7);
    skyColor.b = clamp(skyColor.b, 0.5, 0.9);


    while (steps < 2000) {

        steps++;
        blockPos = DDA_OneUnit(rayOrigin, rayDir, blockPos);
        chunkPos = floor(blockPos / ChunkSize);
        localPos = floor(blockPos) - chunkPos * ChunkSize;

        if (!PositionInBounds(blockPos)) {
            
            float4 chunkNotFoundColor = float4(float3(chunkPos) / float(ChunkDomain), 1.0);
            //float4 chunkNotFoundColor = float4(0.5, 1.0, 0.5, 1);
            //hitColor = chunkNotFoundColor;
            hitColor = skyColor;
            return false;
        }

        float4 blockColor = GetBlock(localPos, chunkPos);

        if (blockColor.a > 0.5) {
            if (OverwriteColor == 1) {
                blockColor = OverwriteValue;
            }

            if (ShadowsOn == 1) {
                float shadow = 1;
                float3 uvNormal;
                float3 UVhit = FindEntryPoint(rayOrigin, rayDir, blockPos, uvNormal);
                //AO = min(UVhit.y - blockPos.y + 0.7, 1);
                shadow = shadow * min(((dot(uvNormal, -float3(0, -1, -0.5)) + 1) / 2) + 0.1, 1);
                blockColor *= shadow;
            }
            
            float3 hitNormal;
            hitPoint = FindEntryPoint(rayOrigin, rayDir, blockPos, hitNormal);
            hitReflection = reflect(rayDir, hitNormal);
            hitColor = blockColor;

            //hitReflection.x += sin(hitPoint.x * 2.34)/10;

            return true;
        }
    }
    hitColor = float4(1.0,1.0,0,0) * steps / 2000;
    return false;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get screenspace UV
    float xProgress = (id.x / ScreenResolutionX);
    float yProgress = (id.y / ScreenResolutionY);
    // Have skycolor for returning at anytime
    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 2 + float4(xProgress, yProgress, 0.0, 1.0) / 2;

    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 5;
    float4 skyColor = float4(0.2, 0.5, 0.8, 1);

    // Create a ray from base of eye
    float3 rayOrigin = CameraPosition;
    float3 rayDir = CameraForward;

    // Add perspective
    float aspectRatio = (ScreenResolutionX / ScreenResolutionY);
    rayDir += CameraRight * (xProgress - 0.5) * aspectRatio;
    rayDir += CameraUp * (yProgress - 0.5);





    //  1: Mask out all rays that never intersect the AABB of the chunks. Used for freecam/editor, but rarely ingame
    int3 boundA = int3(0, 0, 0);
    int3 boundB = int3(1, 1, 1) * ChunkSize * ChunkDomain;
    // Only run this pass on rays that are outside the bounding box
    // This should only happen when in the editor, lol
    if (rayOrigin.x < 0 || rayOrigin.y < 0 || rayOrigin.z < 0 ||
        rayOrigin.x >= boundB.x || rayOrigin.y >= boundB.y || rayOrigin.z >= boundB.z)
    {
        bool3 intersectsFace = bool3(0, 0, 0);
        float3 boundDistance;
        float3 projRay;
        float3 scaleFactors;
        // overstep rays by this margin to ensure they dont get improperly marked outside bounds
        // Set to negative to see problem area where artifacts accrue
        float precisionMargin = 0.0001;

        boundDistance.x = (rayDir.x > 0 ? boundA.x : boundB.x) - rayOrigin.x;
        scaleFactors.x = (boundDistance.x / rayDir.x) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.x > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.x;
            intersectsFace.x = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.y = (rayDir.y > 0 ? boundA.y : boundB.y) - rayOrigin.y;
        scaleFactors.y = (boundDistance.y / rayDir.y) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.y > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.y;
            intersectsFace.y = (
                projRay.x >= boundA.x && projRay.x < boundB.x &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.z = (rayDir.z > 0 ? boundA.z : boundB.z) - rayOrigin.z;
        scaleFactors.z = (boundDistance.z / rayDir.z) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.z > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.z;
            intersectsFace.z = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.x >= boundA.x && projRay.x < boundB.x);
        }

        // If no intersection possible, just return sky color
        if (!intersectsFace.x && !intersectsFace.y && !intersectsFace.z) {
            Result[id.xy] = float4(0.0, 0, 0, 1); return; // MASK COLOR
            //Result[id.xy] =  skyColor*0.95; return; // MASK COLOR
            //Result[id.xy] = skyColor; return; // MASK COLOR
        }


        //  2: if the positions are out of bounds, warp to bounds
        //If we are not inside the bounds, warp forward before deriving
        float entryScale;
        if (intersectsFace.x) {
            entryScale = scaleFactors.x;
        }
        else if (intersectsFace.y) {
            entryScale = scaleFactors.y;
        }
        else {
            entryScale = scaleFactors.z;
        }
        rayOrigin = rayOrigin + rayDir * entryScale;
        //Result[id.xy] = float4(0, 0.1, 0, 1); return; // Draw Mask for affected Rays
    }





    //          Raymarch
    float3 hitPoint;
    float3 hitReflection;
    float4 hitColor;
    
    float4 colorSum = float4(0.0, 0.0, 0.0, 0.0);
    int reflectCount = 1;
    bool rayReflected = true;

    // The first shot will always hit a color, even if its the sky
    // This loop will run at least 1 time to achieve non-reflection cases
    while (rayReflected && reflectCount < MaxReflects + 2) {
        rayReflected = RayMarch(rayOrigin, rayDir, hitPoint, hitReflection, hitColor);

        if (reflectCount == 1) {
            colorSum = hitColor;
        }
        else {
            colorSum += hitColor / reflectCount;
            colorSum = colorSum * float(float(reflectCount) / (float(reflectCount) + 1));
        }

        rayOrigin = hitPoint;
        rayDir = hitReflection;
        reflectCount += 1;
    }
    Result[id.xy] = colorSum;
}

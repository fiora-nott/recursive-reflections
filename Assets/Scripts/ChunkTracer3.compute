#pragma kernel CSMain

RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;

//Texture3D<int> Blocks;
StructuredBuffer<int> BlockBuffer;
StructuredBuffer<int> ChunkBuffer;
int ChunkDomain;
int ChunkSize;

bool ChunkInBounds(int3 chunkPosition) {
    return (
        chunkPosition.x >= 0 &&
        chunkPosition.y >= 0 &&
        chunkPosition.z >= 0 &&
        chunkPosition.x < ChunkDomain &&
        chunkPosition.y < ChunkDomain &&
        chunkPosition.z < ChunkDomain);
}

int GetChunk(int3 chunkPos) {
    return ChunkBuffer[chunkPos.z + ChunkDomain * (chunkPos.y + chunkPos.x * ChunkDomain)];
}

float4 ParseChunkColor(int chunkValue) {
    int r = (chunkValue >> 18) & 0x3F;
    int g = (chunkValue >> 12) & 0x3F;
    int b = (chunkValue >> 6) & 0x3F;
    int a = (chunkValue >> 0) & 0x3F;
    float4 color = float4(r, g, b, a) / 64;
    return color;
}

bool BlockInBounds(int3 blockPos) {
    return (
        blockPos.x >= 0 &&
        blockPos.y >= 0 &&
        blockPos.z >= 0 &&
        blockPos.x < ChunkSize &&
        blockPos.y < ChunkSize &&
        blockPos.z < ChunkSize);
}


float4 GetBlock(int3 blockPos, int brickOffset) {
    int indexLocal = (int)(blockPos.z + ChunkSize * (blockPos.y + blockPos.x * ChunkSize));
    int indexPool = indexLocal + brickOffset;
    int blockValue = BlockBuffer[indexPool];
    int a = (blockValue >> 0) & 0xFF;
    int b = (blockValue >> 8) & 0xFF;
    int g = (blockValue >> 16) & 0xFF;
    int r = (blockValue >> 24) & 0xFF;
    return float4(r, g, b, a) / 255;
}


int3 DDA_OneUnit(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x + 1 - rayOrigin.x;
        else
            distance.x = blockPos.x - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y + 1 - rayOrigin.y;
        else
            distance.y = blockPos.y - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z + 1 - rayOrigin.z;
        else
            distance.z = blockPos.z - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x <= mag.y && mag.x <= mag.z) {
        return blockPos + int3(sign(rayDir.x), 0, 0);
    }
    else if (valid.y && mag.y <= mag.z) {
        return blockPos + int3(0, sign(rayDir.y), 0);
    }
    else {
        return blockPos + int3(0, 0, sign(rayDir.z));
    }
}

int3 Planar(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    // These points represent where all 3 planes intersect
    // There are 2^3=8 possible point-pairs for a given block,
    // Depending on the ray direction
    int3 maxBound = blockPos + int3(1, 1, 1);
    int3 minBound = blockPos;
    // If the ray is traversing across the x-axis
    if (rayDir.x != 0) {
        // See where the ray will next intersect a Z-Y plane (measuring x traversal)
        // Start by obtaining the delta-x value
        float delta;
        if (rayDir.x >= 0) {
            delta = maxBound.x - rayOrigin.x;
        }
        else {
            delta = minBound.x - rayOrigin.x;
        }
        // Find the position on the ray where it hits the plane
        // Since we have like triangles, we only need 1 scalar to find new hypotenuse
        float scaleFactor = delta / rayDir.x; //negative if given impossible blockpos
        float3 hit = rayOrigin + rayDir * scaleFactor;

        // Now we check if our planar intersection is along the block's bounds
        float3 uv;
        uv.x = 0;
        uv.y = hit.y;
        uv.z = hit.z;
        // See if the z and y values is within the defined domains of the block face
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.y >= minBound.y && uv.y <= maxBound.y) {
            // We succesfully found our escape position
            // Calculate the block pos here (outed) and return
            float3 indexOffset = float3(sign(rayDir.x), 0, 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }


    if (rayDir.y != 0) {
        float delta;
        if (rayDir.y >= 0)
            delta = maxBound.y - rayOrigin.y;
        else
            delta = minBound.y - rayOrigin.y;
        float scaleFactor = delta / rayDir.y;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = 0;
        uv.z = hit.z;
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, sign(rayDir.y), 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }
    if (rayDir.z != 0) {
        float delta;
        if (rayDir.z >= 0)
            delta = maxBound.z - rayOrigin.z;
        else
            delta = minBound.z - rayOrigin.z;
        float scaleFactor = delta / rayDir.z;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = hit.y;
        uv.z = 0;
        if (uv.y >= minBound.y && uv.y <= maxBound.y &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, 0, sign(rayDir.z)) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }

    return blockPos + int3(0, 1, 0);
}

float3 FindEntryPoint(float3 rayOrigin, float3 rayDir, int3 blockPos, out int3 normal) {
    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x - rayOrigin.x;
        else
            distance.x = blockPos.x + 1 - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y - rayOrigin.y;
        else
            distance.y = blockPos.y + 1 - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z - rayOrigin.z;
        else
            distance.z = blockPos.z + 1 - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x >= mag.y && mag.x >= mag.z) {
        normal = int3(-sign(rayDir.x), 0, 0);
        return rayOrigin + rayDir * mag.x;
    }
    else if (valid.y && mag.y >= mag.z) {
        normal = int3(0, -sign(rayDir.y), 0);
        return rayOrigin + rayDir * mag.y;
    }
    else {
        normal = int3(0, 0, -sign(rayDir.z));
        return rayOrigin + rayDir * mag.z;
    }
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get screenspace UV
    float xProgress = (id.x / ScreenResolutionX);
    float yProgress = (id.y / ScreenResolutionY);
    // Have skycolor for returning at anytime
    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 2 + float4(xProgress, yProgress, 0.0, 1.0) / 2;

    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 5;
    float4 skyColor = float4(0.2, 0.5, 0.8, 1);

    // Create a ray from base of eye
    float3 rayOrigin = CameraPosition;
    float3 rayDir = CameraForward;

    // Add perspective
    float aspectRatio = (ScreenResolutionX / ScreenResolutionY);
    rayDir += CameraRight * (xProgress - 0.5) * aspectRatio;
    rayDir += CameraUp * (yProgress - 0.5);





    //  1: Mask out all rays that never intersect the AABB of the chunks. Used for freecam/editor, but rarely ingame
    int3 boundA = int3(0, 0, 0);
    int3 boundB = int3(1, 1, 1) * ChunkSize * ChunkDomain;
    // Only run this pass on rays that are outside the bounding box
    // This should only happen when in the editor, lol
    if (rayOrigin.x < 0 || rayOrigin.y < 0 || rayOrigin.z < 0 ||
        rayOrigin.x >= boundB.x || rayOrigin.y >= boundB.y || rayOrigin.z >= boundB.z)
    {
        bool3 intersectsFace = bool3(0, 0, 0);
        float3 boundDistance;
        float3 projRay;
        float3 scaleFactors;
        // overstep rays by this margin to ensure they dont get improperly marked outside bounds
        // Set to negative to see problem area where artifacts accrue
        float precisionMargin = 0.0001;

        boundDistance.x = (rayDir.x > 0 ? boundA.x : boundB.x) - rayOrigin.x;
        scaleFactors.x = (boundDistance.x / rayDir.x) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.x > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.x;
            intersectsFace.x = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.y = (rayDir.y > 0 ? boundA.y : boundB.y) - rayOrigin.y;
        scaleFactors.y = (boundDistance.y / rayDir.y) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.y > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.y;
            intersectsFace.y = (
                projRay.x >= boundA.x && projRay.x < boundB.x &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.z = (rayDir.z > 0 ? boundA.z : boundB.z) - rayOrigin.z;
        scaleFactors.z = (boundDistance.z / rayDir.z) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.z > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.z;
            intersectsFace.z = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.x >= boundA.x && projRay.x < boundB.x);
        }

        // If no intersection possible, just return sky color
        if (!intersectsFace.x && !intersectsFace.y && !intersectsFace.z) {
            Result[id.xy] = float4(1, 0, 0, 1); return; // MASK COLOR
            //Result[id.xy] =  skyColor*0.95; return; // MASK COLOR
            //Result[id.xy] = skyColor; return; // MASK COLOR
        }


        //  2: if the positions are out of bounds, warp to bounds
        //If we are not inside the bounds, warp forward before deriving
        float entryScale;
        if (intersectsFace.x) {
            entryScale = scaleFactors.x;
        }
        else if (intersectsFace.y) {
            entryScale = scaleFactors.y;
        }
        else {
            entryScale = scaleFactors.z;
        }
        rayOrigin = rayOrigin + rayDir * entryScale;
        //Result[id.xy] = float4(0, 0.1, 0, 1); return; // Draw Mask for affected Rays
    }





    //          Raymarch
    float3 rayPos = rayOrigin;
    int3 chunkPos = (floor(rayOrigin / ChunkSize));
    int3 blockPos = floor(rayOrigin - chunkPos * ChunkSize);
    int steps = 0;
    while (steps < 2000) {
        steps++;

        // CRUDE RAYSTEP
        //rayPos = rayPos + rayDir * (float(steps)/(200*5));
        //blockPos = floor(rayPos);

        // PLANAR INTERSECTION
        //blockPos = Planar(rayOrigin, rayDir, blockPos);

        // ONE UNIT DDA
        //blockPos = DDA_OneUnit(rayOrigin, rayDir, blockPos);

        // ONE UNIT RAYPOS
        rayPos = DDA_OneUnit(rayOrigin, rayDir, rayPos);


        chunkPos = floor(rayPos / ChunkSize);
        blockPos = floor(rayPos - chunkPos * ChunkSize);

        if (!ChunkInBounds(chunkPos)) {
            Result[id.xy] = float4(0.5, 1.0, 0.5, 1);
            return;
        }
        /*
        if (!BlockInBounds(blockPos)) {
            //Result[id.xy] = skyColor; 
            //return;
            if (blockPos.x >= ChunkSize) {
                chunkPos.x += 1;
                blockPos.x -= ChunkSize;
            }
            if (blockPos.y >= ChunkSize) {
                chunkPos.y += 1;
                blockPos.y -= ChunkSize;
            }
            if (blockPos.z >= ChunkSize) {
                chunkPos.z += 1;
                blockPos.z -= ChunkSize;
            }

            if (blockPos.x < 0) {
                chunkPos.x -= 1;
                blockPos.x += ChunkSize;
            }
            if (blockPos.y < 0) {
                chunkPos.y -= 1;
                blockPos.y += ChunkSize;
            }
            if (blockPos.z < 0) {
                chunkPos.z -= 1;
                blockPos.z += ChunkSize;
            }
        }
        */

        int chunkValue = GetChunk(chunkPos);
        int poolOffset = chunkValue * pow(ChunkSize, 3);
        float4 color = GetBlock(blockPos, poolOffset);
        //int blockID = GetBlock(blockPos, 0);
        if (color.a > 0.5) {

            float AO = 1;

            
            float3 uvNormal;
            float3 UVhit = FindEntryPoint(rayOrigin, rayDir, blockPos, uvNormal);
            //AO = min(UVhit.y - blockPos.y + 0.7, 1);
            AO = AO * min(((dot(uvNormal, -float3(0, -1, -0.5)) + 1) / 2)+0.1, 1);
            //Result[id.xy] = color * AO;
            //return;
            color *= AO;
            

            bool doReflection = true;

            if (doReflection) {
                //if (color.r%0.1 < 0.05) {

                float4 reflectionColor;
                float3 normal;
                float3 ROrigin = FindEntryPoint(rayOrigin, rayDir, blockPos, normal);
                //float3 reflectDirection = normal;
                float3 RDirection = reflect(rayDir, normal);
                //reflectDirection.x += sin(reflectOrigin.x * 2.34)/40;
                int3 RRayPos = ROrigin;
                int safety = 0;
                while (safety < 1000) {
                    safety++;

                    RRayPos = DDA_OneUnit(ROrigin, RDirection, RRayPos);


                    int3 RChunkPos = floor(RRayPos / ChunkSize);
                    int3 RBlockPos = floor(RRayPos - RChunkPos * ChunkSize);

                    if (!ChunkInBounds(RChunkPos) || !BlockInBounds(RBlockPos)) {
                        Result[id.xy] = color;
                        //Result[id.xy] = skyColor/2 + color / 2;
                        //Result[id.xy] = float4(1.0, 1.0, 0.0, 1.0);
                        return;
                    }
                    int RChunkVal = GetChunk(RChunkPos) * pow(ChunkSize, 3);
                    float4 reflectColor = GetBlock(RBlockPos, RChunkVal);
                    if (reflectColor.a > 0.5) {
                        //Result[id.xy] = float4(1,1,1,1);
                        float3 RUVNormal;
                        float3 RUVhit = FindEntryPoint(ROrigin, RDirection, RBlockPos, RUVNormal);
                        float RAO = 1 * min(((dot(RUVNormal, -float3(0, -1, -0.5)) + 1) / 2) + 0.1, 1);
                        Result[id.xy] = (reflectColor * (1.0/4.0) * RAO + color * (3.0 / 4.0));
                        //Result[id.xy] = reflectColor * (3/4) + color * (1/4);
                        return;
                    }
                }
                // Maximum loop iteration was hit. return mask
                Result[id.xy] = color;
                //Result[id.xy] = float4(0.8, 0.0, 0.5, 1.0);
                return;
            }


            //float4 color;
            //color.r = float(blockPos.x) / ChunkSize;
            //color.g = float(blockPos.y) / ChunkSize;
            //color.b = float(blockPos.z) / ChunkSize;
            //color.a = 1;
            Result[id.xy] = color * AO;
            return;
        }
    }
    Result[id.xy] = skyColor; return;
}

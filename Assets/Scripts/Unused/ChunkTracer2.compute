#pragma kernel CSMain

RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;

//Texture3D<int> Blocks;
StructuredBuffer<int> BlockBuffer;
StructuredBuffer<int> ChunkBuffer;
int ChunkDomain;
int ChunkSize;

bool ChunkInBounds(int3 chunkPosition) {
    return (
        chunkPosition.x >= 0 &&
        chunkPosition.y >= 0 &&
        chunkPosition.z >= 0 &&
        chunkPosition.x < ChunkDomain &&
        chunkPosition.y < ChunkDomain &&
        chunkPosition.z < ChunkDomain);
}

int GetChunk(int3 chunkPos) {
    return ChunkBuffer[chunkPos.z + ChunkDomain * (chunkPos.y + chunkPos.x * ChunkDomain)];
}

float4 ParseChunkColor(int chunkValue) {
    int r = (chunkValue >> 18) & 0x3F;
    int g = (chunkValue >> 12) & 0x3F;
    int b = (chunkValue >> 6) & 0x3F;
    int a = (chunkValue >> 0) & 0x3F;
    float4 color = float4(r, g, b, a) / 64;
    return color;
}

bool BlockInBounds(int3 blockPos) {
    return (
        blockPos.x >= 0 &&
        blockPos.y >= 0 &&
        blockPos.z >= 0 &&
        blockPos.x < ChunkSize &&
        blockPos.y < ChunkSize &&
        blockPos.z < ChunkSize);
}


float4 GetBlock(int3 blockPos, int brickOffset) {
    int indexLocal = (int)(blockPos.z + ChunkSize * (blockPos.y + blockPos.x * ChunkSize));
    int indexPool = indexLocal + brickOffset;
    int blockValue = BlockBuffer[indexPool];
    int a = (blockValue >> 0) & 0xFF;
    int b = (blockValue >> 8) & 0xFF;
    int g = (blockValue >> 16) & 0xFF;
    int r = (blockValue >> 24) & 0xFF;
    return float4(r, g, b, a) / 255;
}


int3 DDA_OneUnit(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x + 1 - rayOrigin.x;
        else
            distance.x = blockPos.x - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y + 1 - rayOrigin.y;
        else
            distance.y = blockPos.y - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z + 1 - rayOrigin.z;
        else
            distance.z = blockPos.z - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x <= mag.y && mag.x <= mag.z) {
        return blockPos + int3(sign(rayDir.x), 0, 0);
    }
    else if (valid.y && mag.y <= mag.z) {
        return blockPos + int3(0, sign(rayDir.y), 0);
    }
    else {
        return blockPos + int3(0, 0, sign(rayDir.z));
    }
}

int3 Planar(float3 rayOrigin, float3 rayDir, int3 blockPos) {

    // These points represent where all 3 planes intersect
    // There are 2^3=8 possible point-pairs for a given block,
    // Depending on the ray direction
    int3 maxBound = blockPos + int3(1, 1, 1);
    int3 minBound = blockPos;
    // If the ray is traversing across the x-axis
    if (rayDir.x != 0) {
        // See where the ray will next intersect a Z-Y plane (measuring x traversal)
        // Start by obtaining the delta-x value
        float delta;
        if (rayDir.x >= 0) {
            delta = maxBound.x - rayOrigin.x;
        }
        else {
            delta = minBound.x - rayOrigin.x;
        }
        // Find the position on the ray where it hits the plane
        // Since we have like triangles, we only need 1 scalar to find new hypotenuse
        float scaleFactor = delta / rayDir.x; //negative if given impossible blockpos
        float3 hit = rayOrigin + rayDir * scaleFactor;

        // Now we check if our planar intersection is along the block's bounds
        float3 uv;
        uv.x = 0;
        uv.y = hit.y;
        uv.z = hit.z;
        // See if the z and y values is within the defined domains of the block face
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.y >= minBound.y && uv.y <= maxBound.y) {
            // We succesfully found our escape position
            // Calculate the block pos here (outed) and return
            float3 indexOffset = float3(sign(rayDir.x), 0, 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }


    if (rayDir.y != 0) {
        float delta;
        if (rayDir.y >= 0)
            delta = maxBound.y - rayOrigin.y;
        else
            delta = minBound.y - rayOrigin.y;
        float scaleFactor = delta / rayDir.y;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = 0;
        uv.z = hit.z;
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, sign(rayDir.y), 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }
    if (rayDir.z != 0) {
        float delta;
        if (rayDir.z >= 0)
            delta = maxBound.z - rayOrigin.z;
        else
            delta = minBound.z - rayOrigin.z;
        float scaleFactor = delta / rayDir.z;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = hit.y;
        uv.z = 0;
        if (uv.y >= minBound.y && uv.y <= maxBound.y &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, 0, sign(rayDir.z)) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }

    return blockPos + int3(0, 1, 0);
}

float3 FindEntryPoint(float3 rayOrigin, float3 rayDir, int3 blockPos, out int3 normal) {
    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = blockPos.x - rayOrigin.x;
        else
            distance.x = blockPos.x + 1 - rayOrigin.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = blockPos.y - rayOrigin.y;
        else
            distance.y = blockPos.y + 1 - rayOrigin.y;
        mag.y = distance.y / rayDir.y;
    }
    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = blockPos.z - rayOrigin.z;
        else
            distance.z = blockPos.z + 1 - rayOrigin.z;
        mag.z = distance.z / rayDir.z;
    }

    if (valid.x && mag.x >= mag.y && mag.x >= mag.z) {
        normal = int3(-sign(rayDir.x), 0, 0);
        return rayOrigin + rayDir * mag.x;
    }
    else if (valid.y && mag.y >= mag.z) {
        normal = int3(0, -sign(rayDir.y), 0);
        return rayOrigin + rayDir * mag.y;
    }
    else {
        normal = int3(0, 0, -sign(rayDir.z));
        return rayOrigin + rayDir * mag.z;
    }
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get screenspace UV
    float xProgress = (id.x / ScreenResolutionX);
    float yProgress = (id.y / ScreenResolutionY);
    // Have skycolor for returning at anytime
    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 2 + float4(xProgress, yProgress, 0.0, 1.0) / 2;
    
    //float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 5;
    float4 skyColor = float4(0.2, 0.5, 0.8, 1);

    // Create a ray from base of eye
    float3 rayOrigin = CameraPosition;
    float3 rayDir = CameraForward;

    // Add perspective
    float aspectRatio = (ScreenResolutionX / ScreenResolutionY);
    rayDir += CameraRight * (xProgress - 0.5) * aspectRatio;
    rayDir += CameraUp * (yProgress - 0.5);





    //  1: Mask out all rays that never intersect the AABB of the chunks. Used for freecam/editor, but rarely ingame
    int3 boundA = int3(0, 0, 0);
    int3 boundB = int3(1, 1, 1) * ChunkSize * ChunkDomain;
    // Only run this pass on rays that are outside the bounding box
    // This should only happen when in the editor, lol
    if (rayOrigin.x < 0 || rayOrigin.y < 0 || rayOrigin.z < 0 ||
        rayOrigin.x >= boundB.x || rayOrigin.y >= boundB.y || rayOrigin.z >= boundB.z)
    {
        bool3 intersectsFace = bool3(0, 0, 0);
        float3 boundDistance;
        float3 projRay;
        float3 scaleFactors;
        // overstep rays by this margin to ensure they dont get improperly marked outside bounds
        // Set to negative to see problem area where artifacts accrue
        float precisionMargin = 0.0001;

        boundDistance.x = (rayDir.x > 0 ? boundA.x : boundB.x) - rayOrigin.x;
        scaleFactors.x = (boundDistance.x / rayDir.x) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.x > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.x;
            intersectsFace.x = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.y = (rayDir.y > 0 ? boundA.y : boundB.y) - rayOrigin.y;
        scaleFactors.y = (boundDistance.y / rayDir.y) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.y > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.y;
            intersectsFace.y = (
                projRay.x >= boundA.x && projRay.x < boundB.x &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.z = (rayDir.z > 0 ? boundA.z : boundB.z) - rayOrigin.z;
        scaleFactors.z = (boundDistance.z / rayDir.z) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.z > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.z;
            intersectsFace.z = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.x >= boundA.x && projRay.x < boundB.x);
        }

        // If no intersection possible, just return sky color
        if (!intersectsFace.x && !intersectsFace.y && !intersectsFace.z) {
            Result[id.xy] = float4(1, 0, 0, 1); return; // MASK COLOR
            //Result[id.xy] =  skyColor*0.95; return; // MASK COLOR
            //Result[id.xy] = skyColor; return; // MASK COLOR
        }


        //  2: if the positions are out of bounds, warp to bounds
        //If we are not inside the bounds, warp forward before deriving
        float entryScale;
        if (intersectsFace.x) {
            entryScale = scaleFactors.x;
        }
        else if (intersectsFace.y) {
            entryScale = scaleFactors.y;
        }
        else {
            entryScale = scaleFactors.z;
        }
        rayOrigin = rayOrigin + rayDir * entryScale;
        //Result[id.xy] = float4(0, 0.1, 0, 1); return; // Draw Mask for affected Rays
    }





    //          Raymarch
    float3 rayPos = rayOrigin;
    int3 blockPos = floor(rayOrigin);
    int steps = 0;
    while (steps < 500) {
        steps++;
        
        // CRUDE RAYSTEP
        //rayPos = rayPos + rayDir * (float(steps)/(500*5));
        //blockPos = floor(rayPos);
        
        // PLANAR INTERSECTION
        //blockPos = Planar(rayOrigin, rayDir, blockPos);
        
        // ONE UNIT DDA
        blockPos = DDA_OneUnit(rayOrigin, rayDir, blockPos);

        if (!BlockInBounds(blockPos)) {
            Result[id.xy] = skyColor; 
            return;
            //continue;
        }

        float4 color = GetBlock(blockPos, 0);
        //int blockID = GetBlock(blockPos, 0);
        if (color.a > 0.5) {

            float AO = 1;

            /*
            float3 uvNormal;
            float3 UVhit = FindEntryPoint(rayOrigin, rayDir, blockPos, uvNormal);
            //AO = min(UVhit.y - blockPos.y + 0.7, 1);
            AO = AO * min(((dot(uvNormal, -float3(0, -1, -0.5)) + 1) / 2)+0.1, 1);
            //Result[id.xy] = color * AO;
            //return;
            */

            bool doReflection = true;
            
            if (doReflection) {
            //if (color.r%0.1 < 0.05) {

                float4 reflectionColor;
                float3 normal;
                float3 reflectOrigin = FindEntryPoint(rayOrigin, rayDir, blockPos, normal);
                //float3 reflectDirection = normal;
                float3 reflectDirection = reflect(rayDir, normal);
                //reflectDirection.x += sin(reflectOrigin.x * 2.34)/40;
                int3 reflectBlockPos = floor(reflectOrigin);
                int safety = 0;
                while (safety < 200) {
                    safety++;
                    reflectBlockPos = DDA_OneUnit(reflectOrigin, reflectDirection, reflectBlockPos);

                    if (!BlockInBounds(reflectBlockPos)) {
                        //Result[id.xy] = skyColor/2 + color / 2;
                        Result[id.xy] =  color * AO;
                        return;
                    }
                    float4 reflectColor = GetBlock(reflectBlockPos, 0);
                    if (reflectColor.a > 0.5) {
                        //Result[id.xy] = float4(1,1,1,1);
                        Result[id.xy] = (reflectColor/2 + color/2) * AO;
                        //Result[id.xy] = reflectColor * (3/4) + color * (1/4);
                        return;
                    }
                }

            }
            

            //float4 color;
            //color.r = float(blockPos.x) / ChunkSize;
            //color.g = float(blockPos.y) / ChunkSize;
            //color.b = float(blockPos.z) / ChunkSize;
            //color.a = 1;
            Result[id.xy] = color * AO;
            return;
        }
    }
    Result[id.xy] = skyColor; return;
}


/*
float3 rayPos = rayOrigin;
float3 priorDisplacement = float3(0,0,0); // remembers which axis was hit last. -normal
int3 chunkPos = floor(rayPos/16);
int3 blockPos = floor(rayPos-chunkPos*16);

int safety1 = 0;
while (ChunkInBounds(chunkPos) && safety1 < 5000) {
//while (chunkPos.x == 0 && chunkPos.y == 0 && chunkPos.z == 0 && safety1 < 5000) {
    safety1 += 1;
    int chunkData = GetChunk(chunkPos);
    bool isBricked = chunkData >> 31;
    int chunkValue = chunkData & 0x7FFFFFFF;

    if (!isBricked) {
        //if chunk is solid, return color
        float4 chunkColor = ParseChunkColor(chunkValue);
        if (chunkColor.a > 0.5) {
            Result[id.xy] = chunkColor;
            return;
        }
        //else chunk is air, let it keep iterating
    }
    //if chunk is bricked, do block raymarching
    else {
        int brickOffset = chunkValue * 4096;
        blockPos = floor(rayPos - chunkPos*16 + priorDisplacement / 2);
        float4 blockColor;
        int safety2 = 0;
        while (BlockInBounds(blockPos) && safety2 < 5000) {
            safety2 += 1;
            //if block is solid, return color
            blockColor = GetBlock(blockPos, brickOffset);
            if (blockColor.a > 0.5) {
                Result[id.xy] = blockColor;
                return;
            }
            //iterate to next block
            rayPos = MarchDDA(rayPos, rayDir, chunkPos*16 + blockPos, 1, priorDisplacement);
            blockPos += priorDisplacement;
        }
        chunkPos += priorDisplacement;
        continue;
    }
    //iterate to next chunk
    rayPos = MarchDDA(rayPos, rayDir, chunkPos * 16, 16, priorDisplacement);
    //derive the new chunk position
    chunkPos += priorDisplacement;
}
Result[id.xy] = skyColor; return;
*/





/*
// PLANAR INTERSECTION
if (rayDir.x != 0) {
    int xAxis = (rayDir.x < 0) ? (blockPos.x - boundSize + 1) : (blockPos.x + boundSize);
    float scaleFactor = ((xAxis - rayEntry.x) / rayDir.x);
    if (scaleFactor >= 0) {
        float3 p = rayEntry + rayDir * scaleFactor;
        if (p.y >= 0 && p.y <= 1 && p.z >= 0 && p.z <= 1) {
            blockPos = blockPos + int3(sign(rayDir.x), 0, 0);
            return p;
        }
    }
}
if (rayDir.y != 0) {
    int yAxis = (rayDir.y < 0) ? (blockPos.y - boundSize + 1) : (blockPos.y + boundSize);
    float scaleFactor = ((yAxis - rayEntry.y) / rayDir.y);
    if (scaleFactor >= 0) {
        float3 p = rayEntry + rayDir * scaleFactor;
        if (p.z >= 0 && p.z <= 1) {
            blockPos = blockPos + int3(0, sign(rayDir.y), 0);
            return p;
        }
    }
}
if (rayDir.z != 0) {
    int zAxis = (rayDir.z < 0) ? (blockPos.z - boundSize + 1) : (blockPos.z + boundSize);
    float scaleFactor = ((zAxis - rayEntry.z) / rayDir.z);
    if (scaleFactor >= 0) {
        float3 p = rayEntry + rayDir * scaleFactor;
        blockPos = blockPos + int3(0, 0, sign(rayDir.z));
        return p;
    }
}
return rayEntry + rayDir * 0.01;
*/


/* // SLOPE WORK
float b = rayEntry.y % 1;
float m = rayDir.y / rayDir.x;
float y = m * boundSize + b;
float scaleFactor = 1;

if (y <= boundSize) {
    //blockPos.x += 1;
    blockPos = blockPos + int3(1, 0, 0);
    float scaleFactor = (ceil(rayEntry.x) - rayEntry.x) / rayDir.x;
}
else {
    //blockPos.y += 1;
    blockPos = blockPos + int3(0, 1, 0);
    float scaleFactor = (ceil(rayEntry.y) - rayEntry.y) / rayDir.y;
}
return rayEntry + rayDir * scaleFactor;



/* DDA WORK
int axis;
float delta;
float scaleFactor;
float3 newRayPos;
if (rayDir.x != 0) {

    //axis = blockPos.x + 0;
    axis = (rayDir.x < 0) ? (blockPos.x - boundSize + 1) : (blockPos.x + boundSize);
    delta = axis - rayOrigin.x;
    scaleFactor = delta / rayDir.x;

    if (scaleFactor > 0) {
        newRayPos = rayOrigin + rayDir * scaleFactor;
        //blockPos += int3(sign(rayDir.x), 0, 0);
        blockPos = floor(newRayPos + float3(sign(rayDir.x)/2, 0, 0));
        return newRayPos;
    }
}
float3 rayNew = rayOrigin + rayDir * boundSize;
blockPos = floor(rayNew);
return rayNew;
*/








    /* WORKING DDA ALGORITHM
    bool3 valid = bool3(
        rayDir.x != 0,
        rayDir.y != 0,
        rayDir.z != 0
        );

    float3 distance = float3(0, 0, 0);
    float3 mag = float3(0, 0, 0);

    if (valid.x) {
        if (rayDir.x > 0)
            distance.x = floor(rayEntry.x + 1) - rayEntry.x;
        else
            distance.x = ceil(rayEntry.x - 1) - rayEntry.x;
        mag.x = distance.x / rayDir.x;
    }
    if (valid.y) {
        if (rayDir.y > 0)
            distance.y = floor(rayEntry.y + 1) - rayEntry.y;
        else
            distance.y = ceil(rayEntry.y - 1) - rayEntry.y;
        mag.y = distance.y / rayDir.y;
    }

    if (valid.z) {
        if (rayDir.z > 0)
            distance.z = floor(rayEntry.z + 1) - rayEntry.z;
        else
            distance.z = ceil(rayEntry.z - 1) - rayEntry.z;
        mag.z = distance.z / rayDir.z;
    }

    float minMag = min(mag.x, min(mag.y, mag.z));
    float3 blockOffset;

    if (mag.x == minMag)
        blockOffset = float3(sign(rayDir.x), 0, 0) / 2;
    else if (mag.y == minMag)
        blockOffset = float3(0, sign(rayDir.y), 0) / 2;
    else
        blockOffset = float3(0, 0, sign(rayDir.z)) / 2;
    

    float3 rayExit = rayEntry + rayDir * minMag;


    blockPos = floor(rayExit + blockOffset);

    return rayExit;
    */




// WORKING PLANAR INTERSECTION ALGORITHM
/*


    // These points represent where all 3 planes intersect
    // There are 2^3=8 possible point-pairs for a given block,
    // Depending on the ray direction
    int3 maxBound = blockPos + int3(1, 1, 1);
    int3 minBound = blockPos;
    // If the ray is traversing across the x-axis
    if (rayDir.x != 0) {
        // See where the ray will next intersect a Z-Y plane (measuring x traversal)
        // Start by obtaining the delta-x value
        float delta;
        if (rayDir.x >= 0) {
            delta = maxBound.x - rayOrigin.x;
        }
        else {
            delta = minBound.x - rayOrigin.x;
        }
        // Find the position on the ray where it hits the plane
        // Since we have like triangles, we only need 1 scalar to find new hypotenuse
        float scaleFactor = delta / rayDir.x; //negative if given impossible blockpos
        float3 hit = rayOrigin + rayDir * scaleFactor;

        // Now we check if our planar intersection is along the block's bounds
        float3 uv;
        uv.x = 0;
        uv.y = hit.y;
        uv.z = hit.z;
        // See if the z and y values is within the defined domains of the block face
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.y >= minBound.y && uv.y <= maxBound.y) {
            // We succesfully found our escape position
            // Calculate the block pos here (outed) and return
            float3 indexOffset = float3(sign(rayDir.x), 0, 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }


    if (rayDir.y != 0) {
        float delta;
        if (rayDir.y >= 0)
            delta = maxBound.y - rayOrigin.y;
        else
            delta = minBound.y - rayOrigin.y;
        float scaleFactor = delta / rayDir.y;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = 0;
        uv.z = hit.z;
        if (uv.z >= minBound.z && uv.z <= maxBound.z &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, sign(rayDir.y), 0) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }
    if (rayDir.z != 0) {
        float delta;
        if (rayDir.z >= 0)
            delta = maxBound.z - rayOrigin.z;
        else
            delta = minBound.z - rayOrigin.z;
        float scaleFactor = delta / rayDir.z;
        float3 hit = rayOrigin + rayDir * scaleFactor;
        float3 uv;
        uv.x = hit.x;
        uv.y = hit.y;
        uv.z = 0;
        if (uv.y >= minBound.y && uv.y <= maxBound.y &&
            uv.x >= minBound.x && uv.x <= maxBound.x) {
            float3 indexOffset = float3(0, 0, sign(rayDir.z)) / 2;
            blockPos = floor(hit + indexOffset);
            return blockPos;
        }
    }

    return blockPos + int3(0, 1, 0);
*/
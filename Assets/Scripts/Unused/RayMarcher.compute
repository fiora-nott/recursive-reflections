// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

ByteAddressBuffer ChunkPointers;
int ChunkDomain;

float3 CameraPosition;

uint GetChunkAddress(int3 chunkPosition) {
    return chunkPosition.z + ChunkDomain * (chunkPosition.y + chunkPosition.x * ChunkDomain);
}

bool GetChunk(int3 chunkPosition, out uint4 chunkData) {
    chunkData = 0;
    // Make sure we are in chunk bounds
    if (chunkPosition.x >= ChunkDomain ||
        chunkPosition.y >= ChunkDomain ||
        chunkPosition.z >= ChunkDomain ||
        chunkPosition.x < 0 ||
        chunkPosition.y < 0 ||
        chunkPosition.z < 0) {
        return false;
    }

    int z_address = GetChunkAddress(chunkPosition);
    chunkData = ChunkPointers.Load4(z_address*4);
    return true;
}

float3 MarchRayBlockspace(float3 rayPos, float3 rayDir) {
    //STEP 1: get origin
    //STEP 2: get direction
    //STEP 3: Calculate hypotenuse slopes for each input axis (IF POSSIBLE), eg. (d-hypotenuse/d-x)
    //STEP 4: Find axis-distance required to march to each possible next axis (0.2 to 1 is 0.8)
    //STEP 5: Find hypotenuse travel magnitude required to reach each next axis (distance * slope)
    //STEP 6: Take the minimum step possible, possibly satisfying multiple axes
    //STEP 7: Examine all possible occupied blocks we are hitting (2^3 in worst case)
    //STEP 8: Repeat until we conclude it is futile (then return sky color)
    // CASE A) Y and Z is zero, ray is on an edge. Will check for collisions From both edges!
    // CASE B) The ray hits a perfect corner (1, 1, 1) and must check 7 blocks around it for collision
    // CASE C) due to a zero value, a slope is infinity. Avoid by marking certain axis as pointless
    // CASE D) traveling in negative direction. Requires different behavior when neighborchecking

    // If given an invalid vector, do not move it at all.
    //invalid vectors may use a 0 Z step if the safety is removed
    if (rayDir.x == 0 && rayDir.y == 0 && rayDir.z == 0) {
        return rayPos;
    }

    // Should be all falses and zeros
    bool3 valid;
    bool3 inverted;
    float3 slope;
    float3 distance;
    float3 magnitude;
    // Get the hypotenuse for the arbitrary magnitude in the direction vector
    float hypotenuseDelta = sqrt(pow(rayDir.x, 2) + pow(rayDir.y, 2) + pow(rayDir.z, 2));
    // Determine if any of the axes are invalid (and should be ignored)
    valid.x = (rayDir.x != 0);
    valid.y = (rayDir.y != 0);
    valid.z = (rayDir.z != 0);
    // Determine which axes should have inverse equations
    inverted.x = (rayDir.x < 0);
    inverted.y = (rayDir.y < 0);
    inverted.z = (rayDir.z < 0);
    // Example axis
    if (valid.x) {
        // Get magnitude slopes. may be negative
        slope.x = hypotenuseDelta / rayDir.x;
        // Get distance to next axis intersection (not next block index)
        // Will be negative for negative ray direction (canceled out in next step)
        distance.x = floor(rayPos.x + (inverted.x ? 0 : 1)) - rayPos.x;
        // See what magnitudes these distances imply for the ray itself
        magnitude.x = distance.x * slope.x;
    }
    if (valid.y) {
        slope.y = hypotenuseDelta / rayDir.y;
        distance.y = floor(rayPos.y + (inverted.y ? 0 : 1)) - rayPos.y;
        magnitude.y = distance.y * slope.y;
    }
    if (valid.z) {
        slope.z = hypotenuseDelta / rayDir.z;
        distance.z = floor(rayPos.z + (inverted.z ? 0 : 1)) - rayPos.z;
        magnitude.z = distance.z * slope.z;
    }
    // Take the minimum step possible that will hit an axis
    float stepDistance;
    if (valid.x && magnitude.x < magnitude.y && magnitude.x < magnitude.z) {
        stepDistance = magnitude.x;
    } 
    else if (valid.y && magnitude.y < magnitude.z) {
        stepDistance = magnitude.y;
    }
    else { //invalid vectors may use a 0 Z step if the safety is removed
        stepDistance = magnitude.z; 
    }

    return rayPos + rayDir * stepDistance;
}

bool CheckRayHitChunk(float3 rayPos, float3 rayDir, out uint4 chunkData) {
    chunkData = 0;
    float3 rayPosAdj = rayPos / 16;
    bool3 inverted;
    float3 step;
    bool3 hitAxis;
    // Determine which axes should have inverse equations
    inverted.x = (rayDir.x < 0);
    inverted.y = (rayDir.y < 0);
    inverted.z = (rayDir.z < 0);
    // Use these offsets to look at neighbors
    step.x = inverted.x ? -0.1 : 0.1;
    step.y = inverted.y ? -0.1 : 0.1;
    step.z = inverted.z ? -0.1 : 0.1;

    // Find which axis our ray points to
    hitAxis.x = rayPosAdj.x % 1 < 0.00001;
    hitAxis.y = rayPosAdj.y % 1 < 0.00001;
    hitAxis.z = rayPosAdj.z % 1 < 0.00001;
    
    // Face intersections
    if (hitAxis.x) {
        if (GetChunk(floor(rayPosAdj + float3(step.x, 0, 0)), chunkData))
            return true;
    }
    if (hitAxis.y) {
        if (GetChunk(floor(rayPosAdj + float3(0, step.y, 0)), chunkData))
            return true;
    }
    if (hitAxis.z) {
        if (GetChunk(floor(rayPosAdj + float3(0, 0, step.z)), chunkData))
            return true;
    }
    // Edge Intersections
    if (hitAxis.x && hitAxis.y) {
        if (GetChunk(floor(rayPosAdj + float3(step.x, step.y, 0)), chunkData))
            return true;
    }
    if (hitAxis.y && hitAxis.z) {
        if (GetChunk(floor(rayPosAdj + float3(0, step.y, step.z)), chunkData))
            return true;
    }
    if (hitAxis.z && hitAxis.x) {
        if (GetChunk(floor(rayPosAdj + float3(step.x, 0, step.z)), chunkData))
            return true;
    }
    // Corner Intersection
    if (hitAxis.x && hitAxis.x) {
        if (GetChunk(floor(rayPosAdj + float3(step.x, step.y, step.z)), chunkData))
            return true;
    }

    return false;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //Get screenspace UV in 0-1 range
    float x = id.x / ScreenResolutionX;
    float y = id.y / ScreenResolutionY;

    /*
    int z_address = GetChunkAddress(uint3(id.x % ChunkDomain, id.y % ChunkDomain, 0));
    uint4 pointer = ChunkPointers.Load4(z_address);

    float color = ((float)(pointer))/255;
    uint dim = 0;
    ChunkPointers.GetDimensions(dim);*/


    float3 rayDir = float3(1, 0, 0); // point in X+ 
    float3 rayPos = CameraPosition; // tracks current position
    int steps = 0; // tracks steps
    //float distance = 0; // tracks progress

    // Create frustrum:
    rayDir.z += (x - 0.5) * (ScreenResolutionX / ScreenResolutionY); // simulate horizontal perspective
    rayDir.y += (y - 0.5); // simulate vertical perspective

    while (steps < 10000) {
        steps += 1;
        // March forward with DDA
        rayPos = MarchRayBlockspace(rayPos, rayDir);
        //rayPos = rayPos + rayDir*0.1;
        
        //get distance to hit next block on x axis

        //Find out which chunk we are hitting
        uint4 pointerData;
        
        /*
        if (GetChunk(rayPos / 16, pointerData) == false) {
            continue;
        }
        */
        
        
        if (CheckRayHitChunk(rayPos, rayDir, pointerData) == false) {
            continue;
        }
        
        /*
        int3 chunkInd = floor(rayPos / 16);
        if (GetChunk(chunkInd, pointerData) == false) {
            continue;
        }
        */
        float pointerF = (float)pointerData;
        if (pointerF <= 50) {
            continue;
        }

        //If the chunk is a solid block, draw its color
        if (pointerF > 50) {
            float4 chunkColor = float4((pointerF-50)/10, 0.0, 0.0, 1.0);
            Result[id.xy] = chunkColor;
            return;
        }
    }
    
    float4 skycolor = float4(0.0, 0.6, 1.0, 1.0);
    Result[id.xy] = skycolor;
    
    
    //Result[id.xy] = float4(color, x, y, 0.0);
}

#pragma kernel CSMain

RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;

//Texture3D<int> Blocks;
StructuredBuffer<int> BlockBuffer;
StructuredBuffer<int> ChunkBuffer;
int ChunkDomain;

bool ChunkInBounds(int3 chunkPosition) {
    return (
        chunkPosition.x >= 0 &&
        chunkPosition.y >= 0 &&
        chunkPosition.z >= 0 &&
        chunkPosition.x < ChunkDomain &&
        chunkPosition.y < ChunkDomain &&
        chunkPosition.z < ChunkDomain);
}

int GetChunk(int3 chunkPos) {
    return ChunkBuffer[chunkPos.z + ChunkDomain * (chunkPos.y + chunkPos.x * ChunkDomain)];
}

float4 ParseChunkColor(int chunkValue) {
    int r = (chunkValue >> 18) & 0x3F;
    int g = (chunkValue >> 12) & 0x3F;
    int b = (chunkValue >> 6) & 0x3F;
    int a = (chunkValue >> 0) & 0x3F;
    float4 color = float4(r, g, b, a) / 64;
    return color;
}

bool BlockInBounds(int3 blockPos) {
    return (
        blockPos.x >= 0 &&
        blockPos.y >= 0 &&
        blockPos.z >= 0 &&
        blockPos.x < 16 &&
        blockPos.y < 16 &&
        blockPos.z < 16);
}

float4 GetBlock(int3 blockPos, int poolOffset) {
    int indexLocal = (int)(blockPos.z + 16 * (blockPos.y + blockPos.x * 16));
    int indexPool = indexLocal + poolOffset;
    int blockValue = BlockBuffer[indexPool];
    int a = (blockValue >> 0) & 0xFF;
    int b = (blockValue >> 8) & 0xFF;
    int g = (blockValue >> 16) & 0xFF;
    int r = (blockValue >> 24) & 0xFF;
    return float4(r,g,b,a) / 255;
}

int3 AdvancePositionDDA(int3 position, float3 rayOrigin, float3 rayDir, float scale) {

    rayOrigin = rayOrigin / scale;

    float xFaceDistance = position.x - rayOrigin.x + (rayDir.x > 0 ? 1 : 0);
    float3 xIntersection = rayOrigin + rayDir * (xFaceDistance / rayDir.x);
    bool hitX =
        xIntersection.y <= position.y + 1 &&
        xIntersection.y >= position.y &&
        xIntersection.z <= position.z + 1 &&
        xIntersection.z >= position.z;
    if (hitX)
        return position + int3(sign(rayDir.x), 0, 0);

    float yFaceDistance = position.y - rayOrigin.y + (rayDir.y > 0 ? 1 : 0);
    float3 yIntersection = rayOrigin + rayDir * (yFaceDistance / rayDir.y);
    bool hitY =
        yIntersection.z <= position.z + 1 &&
        yIntersection.z >= position.z;
    if (hitY)
        return position + int3(0, sign(rayDir.y), 0);

    float zFaceDistance = position.z - rayOrigin.z + (rayDir.z > 0 ? 1 : 0);
    float3 zIntersection = rayOrigin + rayDir * (zFaceDistance / rayDir.z);
    return position + int3(0, 0, sign(rayDir.z));;
}

int3 FindEntryBlockPos(int3 chunkPos, float3 rayOrigin, float3 rayDir) {

    rayOrigin = rayOrigin / 16;
    float errorMargin = 0.0001;

    float xFaceDistance = chunkPos.x - rayOrigin.x + (rayDir.x < 0 ? 1 : 0);
    float3 xIntersection = rayOrigin + rayDir * (xFaceDistance / rayDir.x + errorMargin);
    bool hitX =
        xIntersection.y <= chunkPos.y + 1 &&
        xIntersection.y >= chunkPos.y &&
        xIntersection.z <= chunkPos.z + 1 &&
        xIntersection.z >= chunkPos.z;
    if (hitX)
        return floor(xIntersection * 16)%16;

    float yFaceDistance = chunkPos.y - rayOrigin.y + (rayDir.y < 0 ? 1 : 0);
    float3 yIntersection = rayOrigin + rayDir * (yFaceDistance / rayDir.y + errorMargin);
    bool hitY =
        yIntersection.z <= chunkPos.z + 1 &&
        yIntersection.z >= chunkPos.z;
    if (hitY)
        return floor(yIntersection * 16) % 16;

    float zFaceDistance = chunkPos.z - rayOrigin.z + (rayDir.z < 0 ? 1 : 0);
    float3 zIntersection = rayOrigin + rayDir * (zFaceDistance / rayDir.z + errorMargin);
    return floor(zIntersection * 16) % 16;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Get screenspace UV
    float xProgress = (id.x / ScreenResolutionX);
    float yProgress = (id.y / ScreenResolutionY);
    // Have skycolor for returning at anytime
    float4 skyColor = float4(0.7, 0.9, 1.0, 1.0) / 2 + float4(xProgress, yProgress, 0.0, 1.0) / 2;

    // Create a ray from base of eye
    float3 rayOrigin = CameraPosition;
    float3 rayDir = CameraForward;

    // Add perspective
    float aspectRatio = (ScreenResolutionX / ScreenResolutionY);
    rayDir += CameraRight * (xProgress - 0.5) * aspectRatio;
    rayDir += CameraUp * (yProgress - 0.5);

    //          Raymarch

    //  1: Mask out all rays that never intersect the AABB of the chunks. Used for freecam/editor, but rarely ingame
    int3 boundA = int3(0, 0, 0);
    int3 boundB = int3(16, 16, 16) * ChunkDomain;

    // Only run this pass on rays that are outside the bounding box
    // This should only happen when in the editor, lol
    if (rayOrigin.x < 0 || rayOrigin.y < 0 || rayOrigin.z < 0 ||
        rayOrigin.x >= boundB.x || rayOrigin.y >= boundB.y || rayOrigin.z >= boundB.z) 
    {
        bool3 intersectsFace = bool3(0, 0, 0);
        float3 boundDistance;
        float3 projRay;
        float3 scaleFactors;
        // overstep rays by this margin to ensure they dont get improperly marked outside bounds
        // Set to negative to see problem area where artifacts accrue
        float precisionMargin = 0.0001;

        boundDistance.x = (rayDir.x > 0 ? boundA.x : boundB.x) - rayOrigin.x;
        scaleFactors.x = (boundDistance.x / rayDir.x) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.x > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.x;
            intersectsFace.x = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.y = (rayDir.y > 0 ? boundA.y : boundB.y) - rayOrigin.y;
        scaleFactors.y = (boundDistance.y / rayDir.y) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.y > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.y;
            intersectsFace.y = (
                projRay.x >= boundA.x && projRay.x < boundB.x &&
                projRay.z >= boundA.z && projRay.z < boundB.z);
        }

        boundDistance.z = (rayDir.z > 0 ? boundA.z : boundB.z) - rayOrigin.z;
        scaleFactors.z = (boundDistance.z / rayDir.z) + precisionMargin;
        // Make sure ray is traveling forward to hit the bound, else invalid
        if (scaleFactors.z > 0) {
            projRay = rayOrigin + rayDir * scaleFactors.z;
            intersectsFace.z = (
                projRay.y >= boundA.y && projRay.y < boundB.y &&
                projRay.x >= boundA.x && projRay.x < boundB.x);
        }

        // If no intersection possible, just return sky color
        if (!intersectsFace.x && !intersectsFace.y && !intersectsFace.z) {
            //Result[id.xy] = float4(1, 0, 0, 1); return; // MASK COLOR
            //Result[id.xy] =  skyColor*0.95; return; // MASK COLOR
            Result[id.xy] = skyColor; return; // MASK COLOR
        }


        //  2: if the positions are out of bounds, warp to bounds
        //If we are not inside the bounds, warp forward before deriving
        float entryScale;
        if (intersectsFace.x) {
            entryScale = scaleFactors.x;
        }
        else if (intersectsFace.y) {
            entryScale = scaleFactors.y;
        }
        else {
            entryScale = scaleFactors.z;
        }
        rayOrigin = rayOrigin + rayDir * entryScale;
        //Result[id.xy] = float4(0, 0.1, 0, 1); return; // Draw Mask for affected Rays
    }
    //  3: derive the starting chunk
    int3 chunkPos = floor(rayOrigin / 16);




    //  4: Iterate over every chunk. break if bounds left ever (no recovery)
    int steps = 0;
    while (ChunkInBounds(chunkPos) && steps < 5000) {
        steps++;

        //first bit indicates whether the chunk holds a block ID (including air) or pointer to brick
        //the rest of the bits are either a brick pointer or block ID
        int chunkData = GetChunk(chunkPos);
        bool isBricked = chunkData >> 31; 
        int chunkValue = chunkData & 0x7FFFFFFF;

        //  4.a: when brick found, find block origin and continue DDA until hit block or bounds
        if (isBricked) {
            /*
            float hyp = length(rayDir);
            float3 slope = float3(rayDir.x / hyp, rayDir.y / hyp, rayDir.z / hyp);
            float3 distance = float3(
                chunkPos.x * 16 + (rayDir.x < 0 ? 0 : 16) - rayOrigin.x,
                chunkPos.y * 16 + (rayDir.y < 0 ? 0 : 16) - rayOrigin.y,
                chunkPos.z * 16 + (rayDir.z < 0 ? 0 : 16) - rayOrigin.z);
            float3 effects = float3(slope.x * distance.x, slope.y * distance.y, slope.z * distance.z);
            float minEffect = min(min(effects.x, effects.y), effects.z)+0.0001;
            int3 blockPos = floor(rayOrigin + rayDir * minEffect) % 16;
            */
            int3 blockPos = FindEntryBlockPos(chunkPos, rayOrigin, rayDir);
            int safety = 0;
            int poolOffset = chunkValue * 4096;
            while (BlockInBounds(blockPos) && safety < 1000) {
                safety++;
                float4 color = GetBlock(blockPos, poolOffset);
                if (color.a > 0.5) {
                    Result[id.xy] = color; return;
                }
                blockPos = AdvancePositionDDA(blockPos, rayOrigin-chunkPos*16, rayDir, 1);
            }
            //If no block was found in loop, advance chunk by seeing which boundary the block crossed
            
            if (blockPos.x >= 16)
                chunkPos.x += 1;
            else if (blockPos.y >= 16)
                chunkPos.y += 1;
            else if (blockPos.z >= 16)
                chunkPos.z += 1;

            else if (blockPos.x < 0)
                chunkPos.x -= 1;
            else if (blockPos.y < 0)
                chunkPos.y -= 1;
            else
                chunkPos.z -= 1;
            
            if (!ChunkInBounds(chunkPos)) {
                break;
            }
            //chunkPos = AdvancePositionDDA(chunkPos, rayOrigin, rayDir, 16);

            continue;
            //Result[id.xy] = float4(0.5, 0.5, 0.5, 1);
            //return;
        }
        else {
            float4 color = ParseChunkColor(chunkValue);
            //  4.b: return the chunk's blockID as a block color/texture.
            if (color.a > 0.5) {
                Result[id.xy] = color; return;
            }
            //  4.c: step over air chunks by DDA stepping at 16x scale. Bound check each time
            else {
                //traverse forward
                chunkPos = AdvancePositionDDA(chunkPos, rayOrigin, rayDir, 16);
                continue;
            }
        }
    }
    //  4.c.1: if block hit, return the color value for the pixel
    //  4.c.2: if bound hit, return to chunk scale interation (#4)

    // If nothing hit, return sky color
    Result[id.xy] = skyColor; return;
}

//1: if the starting positions are hopeless, abandon
//2: if the positions are out of bounds, warp to bounds
//3: derive the starting chunk and starting block position
//4: Iterate over every chunk. break if bounds left ever (no recovery)
//4.a: when brick found, find block origin and continue DDA until hit block or bounds
//4.b: return the chunk's blockID as a block color/texture.
//4.c: step over air chunks by DDA stepping at 16x scale. Bound check each time
//4.c.1: if block hit, return the color value for the pixel
//4.c.2: if bound hit, return to chunk scale interation (#4)
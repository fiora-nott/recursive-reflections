#pragma kernel CSMain

RWTexture2D<float4> Result;
float ScreenResolutionX;
float ScreenResolutionY;

float3 CameraPosition;
float3 CameraForward;
float3 CameraRight;
float3 CameraUp;

//Texture3D<int> Blocks;
StructuredBuffer<int> BlockBuffer;

bool GetBlock(int3 blockPos, out float4 color) {
    if (blockPos.x < 0 ||
        blockPos.y < 0 ||
        blockPos.z < 0 ||
        blockPos.x >= 16 ||
        blockPos.y >= 16 ||
        blockPos.z >= 16) {
        color = float4(0, 0, 0, 0);
        return false;
    }

    //int index = blockPos.z + 16 * (blockPos.y + blockPos.x * 16);
    
    //int blockColor = Blocks[blockPos];
    int blockColor = BlockBuffer[(int)(blockPos.z + 16 * (blockPos.y + blockPos.x * 16))];

    int a = (blockColor >>  0) & 0xFF;
    int b = (blockColor >>  8) & 0xFF;
    int g = (blockColor >> 16) & 0xFF;
    int r = (blockColor >> 24) & 0xFF;
    
    color = float4(r, g, b, a) / 255;
    return true;
    //return float4(blockID, (blockID*3)%256, (blockID * 7) % 256, blockID) / 255;

}

bool OutOfBounds(float3 rayPos, float3 rayDir) {
    return (
        (rayPos.x >= 16 && rayDir.x >= 0) ||
        (rayPos.y >= 16 && rayDir.y >= 0) ||
        (rayPos.z >= 16 && rayDir.z >= 0) ||
        (rayPos.x < 0 && rayDir.x <= 0) ||
        (rayPos.y < 0 && rayDir.y <= 0) ||
        (rayPos.z < 0 && rayDir.z <= 0)
        );
}

int3 MarchVoxelDDA(float3 rayOrigin, float3 rayDir, int3 blockPos, out int3 normal, out float2 uv) {
    // Positive X face intersection test

    float xFaceDistance = blockPos.x - rayOrigin.x + (rayDir.x > 0 ? 1 : 0);
    float3 xIntersection = rayOrigin + rayDir * (xFaceDistance / rayDir.x);
    bool hitX =
        xIntersection.y <= blockPos.y + 1 && 
        xIntersection.y >= blockPos.y &&
        xIntersection.z <= blockPos.z + 1 && 
        xIntersection.z >= blockPos.z;
    if (hitX) {
        int3 displacement = int3(sign(rayDir.x), 0, 0);
        normal = -displacement;
        uv.x = xIntersection.z - floor(xIntersection.z);
        uv.y = xIntersection.y - floor(xIntersection.y);
        return blockPos + displacement;
    }

    float yFaceDistance = blockPos.y - rayOrigin.y + (rayDir.y > 0 ? 1 : 0);
    float3 yIntersection = rayOrigin + rayDir * (yFaceDistance / rayDir.y);
    bool hitY =
        yIntersection.z <= blockPos.z + 1 &&
        yIntersection.z >= blockPos.z;
    if (hitY) {
        int3 displacement = int3(0, sign(rayDir.y), 0);
        normal = -displacement;
        uv.x = yIntersection.z - floor(yIntersection.z);
        uv.y = yIntersection.x - floor(yIntersection.x);
        return blockPos + displacement;
    }

    float zFaceDistance = blockPos.z - rayOrigin.z + (rayDir.z > 0 ? 1 : 0);
    float3 zIntersection = rayOrigin + rayDir * (zFaceDistance / rayDir.z);
    int3 displacement = int3(0, 0, sign(rayDir.z));
    normal = -displacement;
    uv.x = zIntersection.y - floor(zIntersection.y);
    uv.y = zIntersection.x - floor(zIntersection.x);
    return blockPos + displacement;
    /*
    // NEG TEST Y
    float yFaceDistance = blockPos.y - rayOrigin.y;
    float3 yIntersection = rayOrigin + rayDir * (yFaceDistance / rayDir.y);
    bool hitY =
        yIntersection.x <= blockPos.x + 1 &&
        yIntersection.x >= blockPos.x &&
        yIntersection.z <= blockPos.z + 1 &&
        yIntersection.z >= blockPos.z;
    if (hitY)
        return blockPos + int3(0, -1, 0);

        // POS TEST Y
    float yFaceDistance = blockPos.y + 1 - rayOrigin.y;
    float3 yIntersection = rayOrigin + rayDir * (yFaceDistance / rayDir.y);
    bool hitY =
        yIntersection.x <= blockPos.x + 1 &&
        yIntersection.x >= blockPos.x &&
        yIntersection.z <= blockPos.z + 1 &&
        yIntersection.z >= blockPos.z;
    if (hitY)
        return blockPos + int3(0, 1, 0);
        */
}
/*
int3 MarchVoxelDDA(float3 rayOrigin, float3 rayDir, int3 blockPos) {
    float rayXY_m = rayDir.y / rayDir.x; //y=m*x, solve for m
    float rayYZ_m = rayDir.z / rayDir.y; //z=m*y, solve for m
    float rayZX_m = rayDir.x / rayDir.z; //x=m*z, solve for m

    float3 blockDir = blockPos - rayOrigin;

    float3 blockDirXY = blockDir + float3(1, 1, 0);
    float3 blockDirYZ = blockDir + float3(0, 1, 1);
    float3 blockDirZX = blockDir + float3(1, 0, 1);
    float blockXY_m = blockDirXY.y / blockDirXY.x;
    float blockYZ_m = blockDirYZ.z / blockDirYZ.y;
    float blockZX_m = blockDirZX.x / blockDirZX.z;

    //check if x-step is the next one
    bool XoverY = rayXY_m <= blockXY_m;
    bool YoverZ = rayYZ_m <= blockYZ_m;
    bool ZoverX = rayZX_m <= blockZX_m;

    if (YoverZ) {
        if (XoverY) {
            return blockPos + int3(1, 0, 0); //X is the next step
        }
        return blockPos + int3(0, 1, 0); //Y is the next step
    }
    return blockPos + int3(0, 0, 1); //Z is the next step
}
*/

/*
float3 MarchBlockDDA(float3 rayPos, float3 rayDir, inout int3 blockPos) {

    float3 valid;
    float3 inverted;
    float3 axisDistance;
    float3 coeff;

    valid.x = rayDir.x != 0;
    if (valid.x) {
        inverted.x = rayDir.x < 0;
        axisDistance.x = floor(rayPos.x + (inverted.x ? 0 : 1)) - rayPos.x;
        coeff.x = axisDistance.x / rayDir.x;
    }

    valid.y = rayDir.y != 0;
    if (valid.y) {
        inverted.y = rayDir.y < 0;
        axisDistance.y = floor(rayPos.y + (inverted.y ? 0 : 1)) - rayPos.y;
        coeff.y = axisDistance.y / rayDir.y;
    }
    
    valid.z = rayDir.z != 0;
    if (valid.z) {
        inverted.z = rayDir.z < 0;
        axisDistance.z = floor(rayPos.z + (inverted.z ? 0 : 1)) - rayPos.z;
        coeff.z = axisDistance.z / rayDir.z;
    }

    float3 newPos;
    float minCoeff;
    if (valid.x && coeff.x <= coeff.y && coeff.x <= coeff.z) {
        minCoeff = coeff.x;
    }
    else if (valid.y && coeff.y <= coeff.z) {
        minCoeff = coeff.y;
    }
    else {
        minCoeff = coeff.z;
    }
    newPos = rayPos + rayDir * minCoeff;
    if (valid.x && minCoeff - coeff.x < 0.00001)
        blockPos = blockPos + int3(sign(rayDir.x), 0, 0);
    if (valid.y && minCoeff - coeff.y < 0.00001)
        blockPos = blockPos + int3(0, sign(rayDir.y), 0);
    if (valid.z && minCoeff - coeff.z < 0.00001)
        blockPos = blockPos + int3(0, 0, sign(rayDir.z));
    return newPos;
}
*/

/*
bool CheckRayHits(float3 rayPos, float3 rayDir, out float4 color) {
    float3 offx, offy, offz;
    offx = (0.5 * sign(rayDir.x), 0, 0);
    offy = (0, 0.5 * sign(rayDir.y), 0);
    offz = (0, 0, 0.5 * sign(rayDir.z));
    bool3 onAxis;
    onAxis.x = rayPos.x - floor(rayPos.x) < 0.01;
    onAxis.y = rayPos.y - floor(rayPos.y) < 0.01;
    onAxis.z = rayPos.z - floor(rayPos.z) < 0.01;

    // Face Cases
    if (onAxis.x && GetBlock(floor(rayPos + offx), color))
        return true;
    if (onAxis.y && GetBlock(floor(rayPos + offy), color))
        return true;
    if (onAxis.z && GetBlock(floor(rayPos + offz), color))
        return true;
    // Edge Cases
    if (onAxis.x && onAxis.y && GetBlock(floor(rayPos + offx + offy), color))
        return true;
    if (onAxis.y && onAxis.z && GetBlock(floor(rayPos + offy + offz), color))
        return true;
    if (onAxis.z && onAxis.x && GetBlock(floor(rayPos + offz + offx), color))
        return true;
    // Corner Case
    if (onAxis.x && onAxis.y && onAxis.z && GetBlock(floor(rayPos + offx + offy + offz), color))
        return true;

    return false;
}*/

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Create a ray from base of eye
    float3 rayOrigin = CameraPosition;
    int3 blockPos = floor(rayOrigin);

    //float3 rayDir = float3(1, 0, 0);
    float3 rayDir = CameraForward;
    //rayDir = normalize(rayDir);

    // Add perspective
    float xProgress = (id.x / ScreenResolutionX);
    float yProgress = (id.y / ScreenResolutionY);
    float aspectRatio = (ScreenResolutionX / ScreenResolutionY);
    rayDir += CameraRight * (xProgress - 0.5) * aspectRatio;
    rayDir += CameraUp * (yProgress - 0.5);
    //rayDir = rayDir / sqrt(pow(rayDir.x, 2) + pow(rayDir.y, 2) + pow(rayDir.z, 2));
    
    //rayPos.z += xProgress;
    //rayPos.y += yProgress;

    // Raymarch
    int step = 0;
    float4 color;
    int3 normal;
    float2 uv;
    while (step < 5000) {
        // if the ray is never going to enter the block region, quit
        // TO-DO MOVE TO BEFORE THE LOOP
        if (OutOfBounds(blockPos, rayDir)) {
            break;
        }
        step += 1;
        // if the ray is outside of the block region but not done, warp to region
        // TO-DO UPDATE BLOCK POSITION

        // Get blockdata at current position (0's for out of bounds)
        if (GetBlock(blockPos, color) && color.a > 0.5) {
            // Lighting with dot product, normal from dda
            float3 lightDirection = -float3(0.4, 0.1, 0.1);
            float light = (dot(normal, lightDirection) + 1) / 2;

            // AO with edge lerping, also from DDA
            //float xEdge = max((abs(uv.x - 0.5) - 0.4), 0) * 10;
            //float yEdge = max((abs(uv.y - 0.5) - 0.4), 0) * 10;
            //float AO = max(xEdge, yEdge);
            //color = lerp(color, color * 0.5, AO);

            // Apply block color to pixel
            Result[id.xy] = color * light;
            return;
        }
        // Move one-unit through the grid, pulling out normal and uv data
        blockPos = MarchVoxelDDA(rayOrigin, rayDir, blockPos, normal, uv);
    }
    // If nothing hit, return sky color
    float4 skyColor = float4(0.7, 0.9, 1.0, 1.0);
    float4 uvColor = float4(xProgress, yProgress, 0.0, 1.0);
    Result[id.xy] = skyColor/2 + uvColor/2;
}
